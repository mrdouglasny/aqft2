Skip to content
Chat history

ChatGPT said:
Short answer: there isnâ€™t a built-in â€œcastâ€ between different realizations of the same Hilbert space. The mathlib way is to work abstractly in a Hilbert space H and then link any concrete realization (e.g. position space LÂ²(Î±, Î¼), momentum space via Fourier, etc.) by a unitary equivalence, i.e. a bundled LinearIsometryEquiv.

That gives you a clean pattern:

Pick your abstract space

variable {ğ•œ : Type*} [IsROrC ğ•œ]
variable (H : Type*) [InnerProductSpace ğ•œ H] [CompleteSpace H]
Pick a concrete realization, e.g. position space

open MeasureTheory
variable {Î± : Type*} [MeasurableSpace Î±] (Î¼ : Measure Î±)
abbrev L2pos := Lp ğ•œ 2 Î¼            -- this is a Hilbert space for p=2
Bundle the change of representation as a unitary equivalence

If you have some â€œdictionaryâ€ (e.g. Fourier/Plancherel, or a measure-preserving change of variables), package it as:

-- abstract <-> concrete
def U_pos  : H â‰ƒâ‚—áµ¢[ğ•œ] L2pos Î¼ := sorry  -- your construction/proof of isometry + linear + bijective
def U_mom  : H â‰ƒâ‚—áµ¢[ğ•œ] L2mom Î½ := sorry  -- another representation (e.g. momentum space)
In practice youâ€™ll either:

build this from first principles (prove linearity + isometry + bijectivity), or

if mathlib already provides the transform you want as an isometry, wrap it here. (Fourier on LÂ² as a unitary exists mathematically; in mathlib4 its fully-bundled LÂ² unitary form may not be ready everywhere yet, so people often define their own LinearIsometryEquiv and use Plancherel-type lemmas to justify it.)

Transport everything along the unitary

Vectors (states):

-- move an abstract vector to position space / back
def Ïˆ_pos : L2pos Î¼ := (U_pos : H â†’áµ¢L2pos Î¼) âŸ¨âŸ¨Â·âŸ©âŸ©? -- just `U_pos v`
-- and back: v = (U_pos.symm) Ïˆ_pos
Operators (observables): conjugate by the unitary

open ContinuousLinearMap

/-- Conjugation of a bounded operator by a unitary equivalence. -/
def conjCLM {E F : Type*} [InnerProductSpace ğ•œ E] [CompleteSpace E]
    [InnerProductSpace ğ•œ F] [CompleteSpace F]
    (U : E â‰ƒâ‚—áµ¢[ğ•œ] F) (T : E â†’L[ğ•œ] E) : F â†’L[ğ•œ] F :=
  (U.toContinuousLinearEquiv : E â‰ƒL[ğ•œ] F).symm.toContinuousLinearMap âˆ˜L
  T âˆ˜L
  (U.toContinuousLinearEquiv : E â‰ƒL[ğ•œ] F).toContinuousLinearMap
-- notation-wise: conjCLM U T = Uâ»Â¹ âˆ˜ T âˆ˜ U on the nose
Now you can define the â€œposition-spaceâ€ representative of an abstract observable:

def T_pos (U_pos : H â‰ƒâ‚—áµ¢[ğ•œ] L2pos Î¼) (T : H â†’L[ğ•œ] H) : L2pos Î¼ â†’L[ğ•œ] L2pos Î¼ :=
  conjCLM U_pos T
and similarly for momentum space using U_mom.

Change-of-variables / other concrete models

If you want to move between two concrete LÂ² spaces on different measure spaces via a measurable equivalence that preserves measure, you can likewise build a LinearIsometryEquiv by composing with the equivalence a.e. and proving itâ€™s an isometry (this is a common pattern for coordinate changes). Once you have that V : Lp ğ•œ 2 Î¼ â‰ƒâ‚—áµ¢[ğ•œ] Lp ğ•œ 2 Î½, you transport states/operators with V and conjCLM V.

Practical tips
Work abstractly in H for most theorems; only â€œchoose a chartâ€ (apply U_pos, U_mom, â€¦) when you need to compute.

Bundle every dictionary/transform you trust as a LinearIsometryEquiv. That buys you:

automatic norm/inner-product preservation,

convenient .symm, .toContinuousLinearEquiv,

easy conjugation of operators, and

painless rewriting via U.injective and U.isometry.

For multiplication by a bounded (measurable) function in LÂ², use a ContinuousLinearMap M_Ï• : LÂ² â†’L LÂ² (as you were building). These interact well with conjugation: e.g. the momentum-space multiplication operator is conjCLM U_mom M_Ï• of the abstract observable.

If you tell me which transforms you want concretely (Fourier on â„^n? unitary coordinate changes via measurable equivalences? wavelet transforms?), I can sketch the corresponding LinearIsometryEquiv wrappers and how to use them to shuttle states and operators back and forth.


